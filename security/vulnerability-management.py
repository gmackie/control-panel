import asyncio
import hashlib
import json
import re
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Any, Tuple
from enum import Enum
import logging
import uuid
import aiohttp
from packaging import version

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityStatus(Enum):
    NEW = "new"
    CONFIRMED = "confirmed"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"
    MITIGATED = "mitigated"
    PATCHED = "patched"

class AssetType(Enum):
    SERVER = "server"
    WORKSTATION = "workstation"
    NETWORK_DEVICE = "network_device"
    APPLICATION = "application"
    CONTAINER = "container"
    CLOUD_RESOURCE = "cloud_resource"
    DATABASE = "database"
    API = "api"

class ScanType(Enum):
    NETWORK = "network"
    WEB_APPLICATION = "web_application"
    AUTHENTICATED = "authenticated"
    COMPLIANCE = "compliance"
    CONTAINER = "container"
    DEPENDENCY = "dependency"
    CODE = "code"

class PatchStatus(Enum):
    AVAILABLE = "available"
    TESTING = "testing"
    APPROVED = "approved"
    SCHEDULED = "scheduled"
    DEPLOYING = "deploying"
    DEPLOYED = "deployed"
    FAILED = "failed"

@dataclass
class Vulnerability:
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cvss_vector: str
    affected_assets: List[str]
    discovered_date: datetime
    status: VulnerabilityStatus = VulnerabilityStatus.NEW
    exploitability: str = "unknown"  # "active", "poc", "theoretical", "unknown"
    patch_available: bool = False
    patch_id: Optional[str] = None
    workaround: Optional[str] = None
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Asset:
    id: str
    name: str
    type: AssetType
    ip_address: Optional[str]
    hostname: Optional[str]
    os: Optional[str]
    os_version: Optional[str]
    criticality: str  # "critical", "high", "medium", "low"
    owner: str
    location: str
    last_scanned: Optional[datetime] = None
    vulnerabilities: List[str] = field(default_factory=list)
    installed_software: List[Dict[str, str]] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ScanResult:
    id: str
    scan_type: ScanType
    target: str
    started_at: datetime
    completed_at: Optional[datetime]
    status: str  # "running", "completed", "failed"
    vulnerabilities_found: List[str] = field(default_factory=list)
    scanner: str = ""
    scan_profile: str = ""
    error_message: Optional[str] = None

@dataclass
class Patch:
    id: str
    vendor: str
    product: str
    version: str
    patch_version: str
    release_date: datetime
    severity: VulnerabilitySeverity
    status: PatchStatus
    vulnerabilities_addressed: List[str]
    affected_assets: List[str]
    prerequisites: List[str] = field(default_factory=list)
    reboot_required: bool = False
    estimated_install_time: int = 30  # minutes
    rollback_available: bool = True
    tested_environments: List[str] = field(default_factory=list)
    deployment_groups: List[str] = field(default_factory=list)

@dataclass
class RiskScore:
    base_score: float
    temporal_score: float
    environmental_score: float
    overall_score: float
    factors: Dict[str, float]
    priority: str  # "immediate", "urgent", "high", "medium", "low"

class VulnerabilityScanner:
    def __init__(self):
        self.scan_profiles = self._initialize_scan_profiles()
        self.active_scans = {}
        
    def _initialize_scan_profiles(self) -> Dict[str, Dict]:
        return {
            'quick': {
                'ports': 'top-100',
                'scripts': 'default',
                'timing': 'aggressive'
            },
            'full': {
                'ports': 'all',
                'scripts': 'default,vuln',
                'timing': 'normal'
            },
            'web': {
                'checks': ['sql_injection', 'xss', 'csrf', 'directory_traversal'],
                'depth': 3,
                'threads': 10
            },
            'compliance': {
                'benchmarks': ['cis', 'pci-dss', 'hipaa'],
                'checks': 'all'
            }
        }
        
    async def scan_asset(self, asset: Asset, scan_type: ScanType, 
                        profile: str = 'quick') -> ScanResult:
        scan_result = ScanResult(
            id=str(uuid.uuid4()),
            scan_type=scan_type,
            target=asset.id,
            started_at=datetime.now(),
            completed_at=None,
            status='running',
            scanner=self._get_scanner_for_type(scan_type),
            scan_profile=profile
        )
        
        self.active_scans[scan_result.id] = scan_result
        
        try:
            if scan_type == ScanType.NETWORK:
                vulnerabilities = await self._network_scan(asset)
            elif scan_type == ScanType.WEB_APPLICATION:
                vulnerabilities = await self._web_application_scan(asset)
            elif scan_type == ScanType.CONTAINER:
                vulnerabilities = await self._container_scan(asset)
            elif scan_type == ScanType.DEPENDENCY:
                vulnerabilities = await self._dependency_scan(asset)
            else:
                vulnerabilities = await self._generic_scan(asset)
                
            scan_result.vulnerabilities_found = [v.id for v in vulnerabilities]
            scan_result.status = 'completed'
            scan_result.completed_at = datetime.now()
            
        except Exception as e:
            scan_result.status = 'failed'
            scan_result.error_message = str(e)
            scan_result.completed_at = datetime.now()
            
        finally:
            if scan_result.id in self.active_scans:
                del self.active_scans[scan_result.id]
                
        return scan_result
        
    def _get_scanner_for_type(self, scan_type: ScanType) -> str:
        scanners = {
            ScanType.NETWORK: 'nmap',
            ScanType.WEB_APPLICATION: 'burp',
            ScanType.CONTAINER: 'trivy',
            ScanType.DEPENDENCY: 'dependency-check',
            ScanType.CODE: 'sonarqube'
        }
        return scanners.get(scan_type, 'generic')
        
    async def _network_scan(self, asset: Asset) -> List[Vulnerability]:
        # Simulate network vulnerability scanning
        await asyncio.sleep(3)
        
        vulnerabilities = []
        
        # Simulate finding some vulnerabilities
        if asset.os and 'Windows' in asset.os:
            vulnerabilities.append(Vulnerability(
                id=str(uuid.uuid4()),
                cve_id='CVE-2024-12345',
                title='Windows Remote Code Execution Vulnerability',
                description='A remote code execution vulnerability exists in Windows',
                severity=VulnerabilitySeverity.CRITICAL,
                cvss_score=9.8,
                cvss_vector='CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                affected_assets=[asset.id],
                discovered_date=datetime.now(),
                patch_available=True
            ))
            
        # Check for open dangerous ports
        dangerous_ports = [23, 135, 139, 445, 3389]
        for port in dangerous_ports:
            if hashlib.md5(f"{asset.id}{port}".encode()).hexdigest()[0] < '8':  # Random simulation
                vulnerabilities.append(Vulnerability(
                    id=str(uuid.uuid4()),
                    cve_id=None,
                    title=f'Dangerous Port {port} Open',
                    description=f'Port {port} is open and may expose the system to attacks',
                    severity=VulnerabilitySeverity.MEDIUM,
                    cvss_score=5.0,
                    cvss_vector='CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N',
                    affected_assets=[asset.id],
                    discovered_date=datetime.now()
                ))
                
        return vulnerabilities
        
    async def _web_application_scan(self, asset: Asset) -> List[Vulnerability]:
        await asyncio.sleep(2)
        
        vulnerabilities = []
        
        # Simulate web app vulnerabilities
        vulnerabilities.append(Vulnerability(
            id=str(uuid.uuid4()),
            cve_id=None,
            title='SQL Injection in Login Form',
            description='The login form is vulnerable to SQL injection attacks',
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
            cvss_vector='CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N',
            affected_assets=[asset.id],
            discovered_date=datetime.now(),
            workaround='Use parameterized queries'
        ))
        
        vulnerabilities.append(Vulnerability(
            id=str(uuid.uuid4()),
            cve_id=None,
            title='Missing Security Headers',
            description='Important security headers are missing',
            severity=VulnerabilitySeverity.LOW,
            cvss_score=3.1,
            cvss_vector='CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N',
            affected_assets=[asset.id],
            discovered_date=datetime.now(),
            workaround='Add X-Frame-Options, X-Content-Type-Options, CSP headers'
        ))
        
        return vulnerabilities
        
    async def _container_scan(self, asset: Asset) -> List[Vulnerability]:
        await asyncio.sleep(2)
        
        vulnerabilities = []
        
        # Simulate container vulnerabilities
        vulnerabilities.append(Vulnerability(
            id=str(uuid.uuid4()),
            cve_id='CVE-2023-98765',
            title='Vulnerable Base Image',
            description='Container uses outdated base image with known vulnerabilities',
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=7.5,
            cvss_vector='CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
            affected_assets=[asset.id],
            discovered_date=datetime.now(),
            patch_available=True,
            workaround='Update to latest base image'
        ))
        
        return vulnerabilities
        
    async def _dependency_scan(self, asset: Asset) -> List[Vulnerability]:
        await asyncio.sleep(1)
        
        vulnerabilities = []
        
        # Check installed software for known vulnerabilities
        for software in asset.installed_software:
            if software.get('name') == 'log4j' and version.parse(software.get('version', '0')) < version.parse('2.17.0'):
                vulnerabilities.append(Vulnerability(
                    id=str(uuid.uuid4()),
                    cve_id='CVE-2021-44228',
                    title='Log4Shell Remote Code Execution',
                    description='Apache Log4j2 vulnerability allows remote code execution',
                    severity=VulnerabilitySeverity.CRITICAL,
                    cvss_score=10.0,
                    cvss_vector='CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H',
                    affected_assets=[asset.id],
                    discovered_date=datetime.now(),
                    patch_available=True,
                    exploitability='active'
                ))
                
        return vulnerabilities
        
    async def _generic_scan(self, asset: Asset) -> List[Vulnerability]:
        await asyncio.sleep(1)
        return []

class RiskCalculator:
    def __init__(self):
        self.threat_intelligence = {}
        self.asset_criticality_weights = {
            'critical': 1.5,
            'high': 1.2,
            'medium': 1.0,
            'low': 0.8
        }
        
    def calculate_risk_score(self, vulnerability: Vulnerability, asset: Asset) -> RiskScore:
        # Base score from CVSS
        base_score = vulnerability.cvss_score
        
        # Temporal factors
        temporal_factors = {
            'exploit_code_maturity': self._get_exploit_maturity_factor(vulnerability),
            'remediation_level': self._get_remediation_factor(vulnerability),
            'report_confidence': 1.0  # Assuming confirmed
        }
        
        temporal_score = base_score * (
            temporal_factors['exploit_code_maturity'] *
            temporal_factors['remediation_level'] *
            temporal_factors['report_confidence']
        )
        
        # Environmental factors
        environmental_factors = {
            'asset_criticality': self.asset_criticality_weights.get(asset.criticality, 1.0),
            'exposure': self._calculate_exposure(asset),
            'data_sensitivity': self._get_data_sensitivity(asset),
            'business_impact': self._calculate_business_impact(asset)
        }
        
        environmental_score = temporal_score * (
            environmental_factors['asset_criticality'] *
            environmental_factors['exposure'] *
            environmental_factors['data_sensitivity']
        )
        
        # Overall score
        overall_score = min(environmental_score, 10.0)
        
        # Determine priority
        priority = self._determine_priority(overall_score, vulnerability.exploitability)
        
        return RiskScore(
            base_score=base_score,
            temporal_score=temporal_score,
            environmental_score=environmental_score,
            overall_score=overall_score,
            factors={**temporal_factors, **environmental_factors},
            priority=priority
        )
        
    def _get_exploit_maturity_factor(self, vulnerability: Vulnerability) -> float:
        maturity_factors = {
            'active': 1.0,
            'poc': 0.96,
            'theoretical': 0.91,
            'unknown': 0.85
        }
        return maturity_factors.get(vulnerability.exploitability, 0.85)
        
    def _get_remediation_factor(self, vulnerability: Vulnerability) -> float:
        if vulnerability.status == VulnerabilityStatus.PATCHED:
            return 0.0
        elif vulnerability.patch_available:
            return 0.95
        elif vulnerability.workaround:
            return 0.97
        else:
            return 1.0
            
    def _calculate_exposure(self, asset: Asset) -> float:
        # Internet-facing assets have higher exposure
        if 'internet-facing' in asset.tags:
            return 1.3
        elif 'dmz' in asset.tags:
            return 1.1
        else:
            return 1.0
            
    def _get_data_sensitivity(self, asset: Asset) -> float:
        if 'pii' in asset.tags or 'phi' in asset.tags:
            return 1.3
        elif 'financial' in asset.tags:
            return 1.2
        elif 'confidential' in asset.tags:
            return 1.1
        else:
            return 1.0
            
    def _calculate_business_impact(self, asset: Asset) -> float:
        if asset.criticality == 'critical':
            return 1.4
        elif asset.criticality == 'high':
            return 1.2
        elif asset.criticality == 'medium':
            return 1.0
        else:
            return 0.8
            
    def _determine_priority(self, score: float, exploitability: str) -> str:
        if score >= 9.0 or exploitability == 'active':
            return 'immediate'
        elif score >= 7.0:
            return 'urgent'
        elif score >= 5.0:
            return 'high'
        elif score >= 3.0:
            return 'medium'
        else:
            return 'low'

class PatchManager:
    def __init__(self):
        self.patches = {}
        self.deployment_windows = {
            'critical': timedelta(days=1),
            'high': timedelta(days=7),
            'medium': timedelta(days=30),
            'low': timedelta(days=90)
        }
        self.test_environments = ['dev', 'staging', 'uat']
        
    def create_patch(self, vulnerability: Vulnerability, vendor: str, 
                     product: str, version: str) -> Patch:
        patch = Patch(
            id=str(uuid.uuid4()),
            vendor=vendor,
            product=product,
            version=version,
            patch_version=f"{version}-patch-{datetime.now().strftime('%Y%m%d')}",
            release_date=datetime.now(),
            severity=vulnerability.severity,
            status=PatchStatus.AVAILABLE,
            vulnerabilities_addressed=[vulnerability.id],
            affected_assets=vulnerability.affected_assets
        )
        
        self.patches[patch.id] = patch
        vulnerability.patch_id = patch.id
        
        return patch
        
    async def test_patch(self, patch_id: str, environment: str) -> Dict[str, Any]:
        if patch_id not in self.patches:
            return {'success': False, 'error': 'Patch not found'}
            
        patch = self.patches[patch_id]
        patch.status = PatchStatus.TESTING
        
        # Simulate patch testing
        await asyncio.sleep(2)
        
        test_result = {
            'success': True,
            'environment': environment,
            'test_date': datetime.now().isoformat(),
            'issues_found': [],
            'performance_impact': 'minimal',
            'compatibility_issues': []
        }
        
        # Random simulation of test issues
        if hashlib.md5(patch_id.encode()).hexdigest()[0] < '2':
            test_result['issues_found'].append('Service restart required')
            test_result['success'] = False
            
        if test_result['success']:
            patch.tested_environments.append(environment)
            
            # Mark as approved if tested in all environments
            if all(env in patch.tested_environments for env in self.test_environments):
                patch.status = PatchStatus.APPROVED
                
        return test_result
        
    async def schedule_deployment(self, patch_id: str, 
                                asset_groups: List[str],
                                deployment_time: Optional[datetime] = None) -> str:
        if patch_id not in self.patches:
            raise ValueError('Patch not found')
            
        patch = self.patches[patch_id]
        
        if patch.status != PatchStatus.APPROVED:
            raise ValueError('Patch must be approved before deployment')
            
        # Calculate deployment time based on severity if not specified
        if not deployment_time:
            deployment_window = self.deployment_windows.get(
                patch.severity.value, 
                timedelta(days=30)
            )
            deployment_time = datetime.now() + deployment_window
            
        patch.status = PatchStatus.SCHEDULED
        patch.deployment_groups = asset_groups
        
        deployment_id = str(uuid.uuid4())
        
        # Schedule deployment task
        asyncio.create_task(self._deploy_patch(patch_id, deployment_time, deployment_id))
        
        return deployment_id
        
    async def _deploy_patch(self, patch_id: str, deployment_time: datetime, 
                          deployment_id: str):
        # Wait until deployment time
        wait_seconds = (deployment_time - datetime.now()).total_seconds()
        if wait_seconds > 0:
            await asyncio.sleep(min(wait_seconds, 5))  # Cap at 5 seconds for demo
            
        patch = self.patches[patch_id]
        patch.status = PatchStatus.DEPLOYING
        
        # Simulate deployment
        await asyncio.sleep(3)
        
        # Random success/failure
        if hashlib.md5(deployment_id.encode()).hexdigest()[0] < 'e':
            patch.status = PatchStatus.DEPLOYED
            logging.info(f"Patch {patch_id} deployed successfully")
        else:
            patch.status = PatchStatus.FAILED
            logging.error(f"Patch {patch_id} deployment failed")
            
    def get_patch_metrics(self) -> Dict[str, Any]:
        total_patches = len(self.patches)
        
        status_distribution = {}
        severity_distribution = {}
        
        for patch in self.patches.values():
            status_distribution[patch.status.value] = status_distribution.get(patch.status.value, 0) + 1
            severity_distribution[patch.severity.value] = severity_distribution.get(patch.severity.value, 0) + 1
            
        return {
            'total_patches': total_patches,
            'status_distribution': status_distribution,
            'severity_distribution': severity_distribution,
            'patches_pending_deployment': sum(1 for p in self.patches.values() 
                                            if p.status in [PatchStatus.APPROVED, PatchStatus.SCHEDULED])
        }

class VulnerabilityManagementSystem:
    def __init__(self):
        self.scanner = VulnerabilityScanner()
        self.risk_calculator = RiskCalculator()
        self.patch_manager = PatchManager()
        self.vulnerabilities = {}
        self.assets = {}
        self.scan_results = []
        self.scan_schedule = {}
        
    async def initialize(self):
        # Load threat intelligence feeds
        await self._load_threat_intelligence()
        
        # Initialize scan schedules
        self._initialize_scan_schedules()
        
    async def _load_threat_intelligence(self):
        # Simulate loading threat intelligence
        await asyncio.sleep(1)
        logging.info("Threat intelligence feeds loaded")
        
    def _initialize_scan_schedules(self):
        self.scan_schedule = {
            'critical_assets': timedelta(days=1),
            'high_assets': timedelta(days=7),
            'medium_assets': timedelta(days=14),
            'low_assets': timedelta(days=30)
        }
        
    def register_asset(self, asset: Asset) -> str:
        self.assets[asset.id] = asset
        return asset.id
        
    async def scan_asset(self, asset_id: str, scan_type: ScanType = ScanType.NETWORK) -> str:
        if asset_id not in self.assets:
            raise ValueError('Asset not found')
            
        asset = self.assets[asset_id]
        
        # Perform scan
        scan_result = await self.scanner.scan_asset(asset, scan_type)
        self.scan_results.append(scan_result)
        
        # Process discovered vulnerabilities
        vulnerabilities = []
        for vuln in await self.scanner._network_scan(asset):  # Get actual vulnerabilities
            self.vulnerabilities[vuln.id] = vuln
            asset.vulnerabilities.append(vuln.id)
            vulnerabilities.append(vuln)
            
        # Calculate risk scores
        for vuln in vulnerabilities:
            risk_score = self.risk_calculator.calculate_risk_score(vuln, asset)
            vuln.metadata['risk_score'] = risk_score
            
            # Create patches for high-risk vulnerabilities
            if risk_score.priority in ['immediate', 'urgent'] and vuln.patch_available:
                patch = self.patch_manager.create_patch(
                    vuln, 
                    'Microsoft' if 'Windows' in (asset.os or '') else 'Linux',
                    asset.os or 'Unknown',
                    asset.os_version or '1.0'
                )
                
        asset.last_scanned = datetime.now()
        
        return scan_result.id
        
    async def get_vulnerability_report(self, asset_id: Optional[str] = None) -> Dict[str, Any]:
        if asset_id:
            if asset_id not in self.assets:
                return {'error': 'Asset not found'}
                
            asset = self.assets[asset_id]
            asset_vulns = [self.vulnerabilities[vid] for vid in asset.vulnerabilities 
                         if vid in self.vulnerabilities]
                         
            return {
                'asset_id': asset_id,
                'asset_name': asset.name,
                'last_scanned': asset.last_scanned.isoformat() if asset.last_scanned else None,
                'total_vulnerabilities': len(asset_vulns),
                'severity_distribution': self._get_severity_distribution(asset_vulns),
                'top_vulnerabilities': self._get_top_vulnerabilities(asset_vulns, 5),
                'patch_status': self._get_patch_status(asset_vulns)
            }
        else:
            # Overall report
            all_vulns = list(self.vulnerabilities.values())
            
            return {
                'total_assets': len(self.assets),
                'total_vulnerabilities': len(all_vulns),
                'severity_distribution': self._get_severity_distribution(all_vulns),
                'exploitable_vulnerabilities': sum(1 for v in all_vulns 
                                                 if v.exploitability in ['active', 'poc']),
                'assets_at_risk': sum(1 for a in self.assets.values() 
                                    if any(self.vulnerabilities.get(vid, {}).get('severity') == VulnerabilitySeverity.CRITICAL 
                                         for vid in a.vulnerabilities)),
                'patch_metrics': self.patch_manager.get_patch_metrics(),
                'recent_scans': len([s for s in self.scan_results 
                                   if s.completed_at and 
                                   s.completed_at > datetime.now() - timedelta(days=7)])
            }
            
    def _get_severity_distribution(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        distribution = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in vulnerabilities:
            distribution[vuln.severity.value] += 1
        return distribution
        
    def _get_top_vulnerabilities(self, vulnerabilities: List[Vulnerability], 
                                limit: int = 5) -> List[Dict[str, Any]]:
        # Sort by risk score
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: v.metadata.get('risk_score', RiskScore(0, 0, 0, 0, {}, 'low')).overall_score,
            reverse=True
        )
        
        return [
            {
                'id': v.id,
                'title': v.title,
                'severity': v.severity.value,
                'risk_score': v.metadata.get('risk_score', {}).overall_score if isinstance(v.metadata.get('risk_score'), RiskScore) else 0,
                'exploitability': v.exploitability,
                'patch_available': v.patch_available
            }
            for v in sorted_vulns[:limit]
        ]
        
    def _get_patch_status(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        status = {
            'patched': 0,
            'patch_available': 0,
            'workaround_available': 0,
            'no_remediation': 0
        }
        
        for vuln in vulnerabilities:
            if vuln.status == VulnerabilityStatus.PATCHED:
                status['patched'] += 1
            elif vuln.patch_available:
                status['patch_available'] += 1
            elif vuln.workaround:
                status['workaround_available'] += 1
            else:
                status['no_remediation'] += 1
                
        return status
        
    async def remediate_vulnerability(self, vulnerability_id: str, 
                                    method: str = 'patch') -> Dict[str, Any]:
        if vulnerability_id not in self.vulnerabilities:
            return {'success': False, 'error': 'Vulnerability not found'}
            
        vuln = self.vulnerabilities[vulnerability_id]
        
        if method == 'patch' and vuln.patch_available and vuln.patch_id:
            # Test and deploy patch
            patch = self.patch_manager.patches[vuln.patch_id]
            
            # Test in all environments
            for env in self.patch_manager.test_environments:
                test_result = await self.patch_manager.test_patch(vuln.patch_id, env)
                if not test_result['success']:
                    return {
                        'success': False,
                        'error': f"Patch testing failed in {env}",
                        'details': test_result
                    }
                    
            # Schedule deployment
            deployment_id = await self.patch_manager.schedule_deployment(
                vuln.patch_id,
                vuln.affected_assets
            )
            
            vuln.status = VulnerabilityStatus.MITIGATED
            
            return {
                'success': True,
                'method': 'patch',
                'deployment_id': deployment_id,
                'status': 'scheduled'
            }
            
        elif method == 'workaround' and vuln.workaround:
            # Apply workaround
            vuln.status = VulnerabilityStatus.MITIGATED
            
            return {
                'success': True,
                'method': 'workaround',
                'workaround_applied': vuln.workaround
            }
            
        elif method == 'accept_risk':
            vuln.status = VulnerabilityStatus.ACCEPTED_RISK
            
            return {
                'success': True,
                'method': 'risk_accepted',
                'risk_score': vuln.metadata.get('risk_score', {}).overall_score if isinstance(vuln.metadata.get('risk_score'), RiskScore) else 'unknown'
            }
            
        else:
            return {
                'success': False,
                'error': 'Remediation method not available'
            }
            
    async def get_dashboard_metrics(self) -> Dict[str, Any]:
        total_vulns = len(self.vulnerabilities)
        critical_vulns = sum(1 for v in self.vulnerabilities.values() 
                           if v.severity == VulnerabilitySeverity.CRITICAL)
        
        exploitable = sum(1 for v in self.vulnerabilities.values() 
                        if v.exploitability in ['active', 'poc'])
        
        mean_time_to_patch = self._calculate_mean_time_to_patch()
        
        return {
            'total_vulnerabilities': total_vulns,
            'critical_vulnerabilities': critical_vulns,
            'exploitable_vulnerabilities': exploitable,
            'assets_scanned_today': sum(1 for a in self.assets.values() 
                                      if a.last_scanned and 
                                      a.last_scanned.date() == datetime.now().date()),
            'patches_pending': sum(1 for p in self.patch_manager.patches.values() 
                                 if p.status in [PatchStatus.AVAILABLE, PatchStatus.APPROVED]),
            'mean_time_to_patch_days': mean_time_to_patch,
            'vulnerability_trend': self._calculate_vulnerability_trend(),
            'top_vulnerable_assets': self._get_top_vulnerable_assets(5)
        }
        
    def _calculate_mean_time_to_patch(self) -> float:
        patched_vulns = [v for v in self.vulnerabilities.values() 
                        if v.status == VulnerabilityStatus.PATCHED]
        
        if not patched_vulns:
            return 0.0
            
        total_days = 0
        for vuln in patched_vulns:
            if vuln.patch_id and vuln.patch_id in self.patch_manager.patches:
                patch = self.patch_manager.patches[vuln.patch_id]
                if patch.status == PatchStatus.DEPLOYED:
                    days = (datetime.now() - vuln.discovered_date).days
                    total_days += days
                    
        return total_days / len(patched_vulns) if patched_vulns else 0.0
        
    def _calculate_vulnerability_trend(self) -> Dict[str, int]:
        # Calculate vulnerability count over last 30 days
        trend = {}
        for i in range(30):
            date = (datetime.now() - timedelta(days=i)).date()
            count = sum(1 for v in self.vulnerabilities.values() 
                      if v.discovered_date.date() <= date and 
                      v.status not in [VulnerabilityStatus.PATCHED, VulnerabilityStatus.FALSE_POSITIVE])
            trend[date.isoformat()] = count
            
        return trend
        
    def _get_top_vulnerable_assets(self, limit: int = 5) -> List[Dict[str, Any]]:
        asset_scores = []
        
        for asset in self.assets.values():
            total_score = 0
            critical_count = 0
            
            for vuln_id in asset.vulnerabilities:
                if vuln_id in self.vulnerabilities:
                    vuln = self.vulnerabilities[vuln_id]
                    if vuln.severity == VulnerabilitySeverity.CRITICAL:
                        critical_count += 1
                    risk_score = vuln.metadata.get('risk_score')
                    if isinstance(risk_score, RiskScore):
                        total_score += risk_score.overall_score
                        
            if total_score > 0:
                asset_scores.append({
                    'asset_id': asset.id,
                    'asset_name': asset.name,
                    'risk_score': total_score,
                    'vulnerability_count': len(asset.vulnerabilities),
                    'critical_count': critical_count
                })
                
        return sorted(asset_scores, key=lambda x: x['risk_score'], reverse=True)[:limit]

# Example usage
async def main():
    vm_system = VulnerabilityManagementSystem()
    await vm_system.initialize()
    
    # Register assets
    server1 = Asset(
        id="srv-001",
        name="Production Web Server",
        type=AssetType.SERVER,
        ip_address="192.168.1.10",
        hostname="web-prod-01",
        os="Windows Server 2019",
        os_version="10.0.17763",
        criticality="critical",
        owner="IT Operations",
        location="Datacenter A",
        tags=["internet-facing", "pii"],
        installed_software=[
            {"name": "log4j", "version": "2.14.0"},
            {"name": "apache", "version": "2.4.46"}
        ]
    )
    
    vm_system.register_asset(server1)
    
    # Scan the asset
    scan_id = await vm_system.scan_asset(server1.id, ScanType.NETWORK)
    print(f"Scan completed: {scan_id}")
    
    # Get vulnerability report
    report = await vm_system.get_vulnerability_report(server1.id)
    print(f"Vulnerability Report: {report}")
    
    # Get overall dashboard metrics
    metrics = await vm_system.get_dashboard_metrics()
    print(f"Dashboard Metrics: {metrics}")
    
    # Remediate a vulnerability
    if vm_system.vulnerabilities:
        vuln_id = list(vm_system.vulnerabilities.keys())[0]
        remediation_result = await vm_system.remediate_vulnerability(vuln_id, 'patch')
        print(f"Remediation Result: {remediation_result}")

if __name__ == "__main__":
    asyncio.run(main())