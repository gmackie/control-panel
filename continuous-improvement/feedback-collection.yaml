# User Feedback Collection System
# Collects and processes user feedback for continuous improvement

---
# Feedback Collection API
apiVersion: apps/v1
kind: Deployment
metadata:
  name: feedback-collector
  namespace: monitoring
  labels:
    app: feedback-collector
spec:
  replicas: 2
  selector:
    matchLabels:
      app: feedback-collector
  template:
    metadata:
      labels:
        app: feedback-collector
    spec:
      containers:
      - name: feedback-api
        image: python:3.11-slim
        ports:
        - containerPort: 5000
        command:
        - /bin/sh
        - -c
        - |
          pip install flask requests pandas sqlalchemy psycopg2-binary &&
          python /app/feedback_api.py
        volumeMounts:
        - name: app-code
          mountPath: /app
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: feedback-db-secret
              key: database-url
        - name: SLACK_WEBHOOK_URL
          valueFrom:
            secretKeyRef:
              name: notification-secrets
              key: slack-webhook
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
      volumes:
      - name: app-code
        configMap:
          name: feedback-app-code

---
apiVersion: v1
kind: Service
metadata:
  name: feedback-collector-service
  namespace: monitoring
spec:
  selector:
    app: feedback-collector
  ports:
  - port: 80
    targetPort: 5000
  type: ClusterIP

---
# Feedback Database
apiVersion: apps/v1
kind: Deployment
metadata:
  name: feedback-postgres
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: feedback-postgres
  template:
    metadata:
      labels:
        app: feedback-postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: feedback
        - name: POSTGRES_USER
          value: feedback_user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: feedback-db-secret
              key: password
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        - name: init-sql
          mountPath: /docker-entrypoint-initdb.d
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: feedback-postgres-pvc
      - name: init-sql
        configMap:
          name: feedback-db-init

---
apiVersion: v1
kind: Service
metadata:
  name: feedback-postgres-service
  namespace: monitoring
spec:
  selector:
    app: feedback-postgres
  ports:
  - port: 5432
  type: ClusterIP

---
# Feedback Processing System
apiVersion: v1
kind: ConfigMap
metadata:
  name: feedback-app-code
  namespace: monitoring
data:
  feedback_api.py: |
    #!/usr/bin/env python3
    """
    Feedback Collection API
    Collects user feedback and processes it for continuous improvement
    """
    
    import os
    import json
    from datetime import datetime
    from flask import Flask, request, jsonify
    import requests
    import pandas as pd
    from sqlalchemy import create_engine, text
    
    
    app = Flask(__name__)
    
    # Configuration
    DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://feedback_user:password@feedback-postgres-service:5432/feedback')
    SLACK_WEBHOOK_URL = os.getenv('SLACK_WEBHOOK_URL')
    
    # Database connection
    engine = create_engine(DATABASE_URL)
    
    
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({'status': 'healthy', 'timestamp': datetime.utcnow().isoformat()})
    
    
    @app.route('/feedback', methods=['POST'])
    def submit_feedback():
        """Submit user feedback"""
        try:
            data = request.get_json()
            
            # Validate required fields
            required_fields = ['type', 'message', 'user_id']
            if not all(field in data for field in required_fields):
                return jsonify({'error': 'Missing required fields'}), 400
            
            # Insert feedback into database
            feedback_id = store_feedback(data)
            
            # Process feedback for immediate issues
            process_feedback(data, feedback_id)
            
            return jsonify({
                'success': True,
                'feedback_id': feedback_id,
                'message': 'Feedback submitted successfully'
            }), 201
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    
    @app.route('/feedback', methods=['GET'])
    def get_feedback():
        """Get feedback data for analysis"""
        try:
            # Query parameters
            limit = request.args.get('limit', 100, type=int)
            feedback_type = request.args.get('type')
            severity = request.args.get('severity')
            
            # Build query
            query = "SELECT * FROM feedback WHERE 1=1"
            params = {}
            
            if feedback_type:
                query += " AND type = %(type)s"
                params['type'] = feedback_type
            
            if severity:
                query += " AND severity = %(severity)s"
                params['severity'] = severity
            
            query += " ORDER BY created_at DESC LIMIT %(limit)s"
            params['limit'] = limit
            
            # Execute query
            with engine.connect() as conn:
                result = conn.execute(text(query), params)
                feedback = [dict(row._mapping) for row in result]
            
            return jsonify({
                'feedback': feedback,
                'count': len(feedback)
            })
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    
    @app.route('/feedback/analytics', methods=['GET'])
    def get_feedback_analytics():
        """Get feedback analytics"""
        try:
            analytics = generate_feedback_analytics()
            return jsonify(analytics)
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    
    def store_feedback(data):
        """Store feedback in database"""
        # Determine severity based on feedback type and content
        severity = determine_severity(data)
        
        # Prepare data
        feedback_data = {
            'type': data['type'],
            'message': data['message'],
            'user_id': data['user_id'],
            'severity': severity,
            'page_url': data.get('page_url'),
            'user_agent': data.get('user_agent'),
            'session_id': data.get('session_id'),
            'metadata': json.dumps(data.get('metadata', {})),
            'created_at': datetime.utcnow()
        }
        
        # Insert into database
        query = """
        INSERT INTO feedback (type, message, user_id, severity, page_url, user_agent, session_id, metadata, created_at)
        VALUES (%(type)s, %(message)s, %(user_id)s, %(severity)s, %(page_url)s, %(user_agent)s, %(session_id)s, %(metadata)s, %(created_at)s)
        RETURNING id
        """
        
        with engine.connect() as conn:
            result = conn.execute(text(query), feedback_data)
            conn.commit()
            return result.fetchone()[0]
    
    
    def determine_severity(data):
        """Determine feedback severity based on type and content"""
        feedback_type = data['type'].lower()
        message = data['message'].lower()
        
        # Critical keywords
        critical_keywords = ['broken', 'error', 'crash', 'not working', 'failed', 'bug']
        high_keywords = ['slow', 'problem', 'issue', 'difficult', 'confusing']
        
        if feedback_type == 'bug':
            if any(keyword in message for keyword in critical_keywords):
                return 'critical'
            else:
                return 'high'
        elif feedback_type == 'performance':
            return 'medium'
        elif feedback_type == 'feature_request':
            return 'low'
        elif any(keyword in message for keyword in critical_keywords):
            return 'high'
        elif any(keyword in message for keyword in high_keywords):
            return 'medium'
        else:
            return 'low'
    
    
    def process_feedback(data, feedback_id):
        """Process feedback for immediate actions"""
        severity = determine_severity(data)
        
        # Send critical feedback to Slack immediately
        if severity == 'critical' and SLACK_WEBHOOK_URL:
            send_critical_feedback_alert(data, feedback_id)
        
        # Check for patterns that need immediate attention
        check_feedback_patterns(data)
    
    
    def send_critical_feedback_alert(data, feedback_id):
        """Send critical feedback alert to Slack"""
        message = {
            "text": f"ðŸš¨ Critical User Feedback Alert",
            "attachments": [
                {
                    "color": "danger",
                    "fields": [
                        {"title": "Type", "value": data['type'], "short": True},
                        {"title": "User", "value": data['user_id'], "short": True},
                        {"title": "Message", "value": data['message'][:200] + "..." if len(data['message']) > 200 else data['message']},
                        {"title": "Page", "value": data.get('page_url', 'Unknown'), "short": True},
                        {"title": "Feedback ID", "value": str(feedback_id), "short": True}
                    ],
                    "footer": "Feedback System",
                    "ts": int(datetime.utcnow().timestamp())
                }
            ]
        }
        
        try:
            requests.post(SLACK_WEBHOOK_URL, json=message, timeout=5)
        except:
            pass  # Don't fail feedback submission if Slack fails
    
    
    def check_feedback_patterns(data):
        """Check for patterns that might indicate system issues"""
        # Check for multiple similar complaints in the last hour
        query = """
        SELECT COUNT(*) as count
        FROM feedback
        WHERE type = %(type)s
        AND severity IN ('critical', 'high')
        AND created_at > (NOW() - INTERVAL '1 hour')
        """
        
        with engine.connect() as conn:
            result = conn.execute(text(query), {'type': data['type']})
            count = result.fetchone()[0]
            
            # If more than 3 similar critical/high severity feedback in an hour, alert
            if count > 3:
                send_pattern_alert(data['type'], count)
    
    
    def send_pattern_alert(feedback_type, count):
        """Send pattern alert to Slack"""
        if not SLACK_WEBHOOK_URL:
            return
        
        message = {
            "text": f"âš ï¸ Feedback Pattern Alert: {count} {feedback_type} complaints in the last hour",
            "color": "warning"
        }
        
        try:
            requests.post(SLACK_WEBHOOK_URL, json=message, timeout=5)
        except:
            pass
    
    
    def generate_feedback_analytics():
        """Generate feedback analytics"""
        # Get feedback summary
        summary_query = """
        SELECT 
            type,
            severity,
            COUNT(*) as count,
            AVG(EXTRACT(EPOCH FROM (NOW() - created_at))/3600) as avg_age_hours
        FROM feedback
        WHERE created_at > (NOW() - INTERVAL '7 days')
        GROUP BY type, severity
        ORDER BY count DESC
        """
        
        # Get trending issues
        trending_query = """
        SELECT 
            type,
            COUNT(*) as count,
            COUNT(*) - LAG(COUNT(*)) OVER (ORDER BY DATE(created_at)) as trend
        FROM feedback
        WHERE created_at > (NOW() - INTERVAL '14 days')
        GROUP BY type, DATE(created_at)
        ORDER BY count DESC
        LIMIT 10
        """
        
        with engine.connect() as conn:
            # Get summary
            summary_result = conn.execute(text(summary_query))
            summary = [dict(row._mapping) for row in summary_result]
            
            # Get trending
            trending_result = conn.execute(text(trending_query))
            trending = [dict(row._mapping) for row in trending_result]
        
        return {
            'summary': summary,
            'trending_issues': trending,
            'generated_at': datetime.utcnow().isoformat()
        }
    
    
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=False)

---
# Database initialization
apiVersion: v1
kind: ConfigMap
metadata:
  name: feedback-db-init
  namespace: monitoring
data:
  init.sql: |
    -- Create feedback table
    CREATE TABLE IF NOT EXISTS feedback (
        id SERIAL PRIMARY KEY,
        type VARCHAR(50) NOT NULL,
        message TEXT NOT NULL,
        user_id VARCHAR(100) NOT NULL,
        severity VARCHAR(20) NOT NULL DEFAULT 'low',
        page_url TEXT,
        user_agent TEXT,
        session_id VARCHAR(100),
        metadata JSONB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        processed BOOLEAN DEFAULT FALSE,
        processed_at TIMESTAMP
    );
    
    -- Create indexes for better performance
    CREATE INDEX IF NOT EXISTS idx_feedback_type ON feedback(type);
    CREATE INDEX IF NOT EXISTS idx_feedback_severity ON feedback(severity);
    CREATE INDEX IF NOT EXISTS idx_feedback_created_at ON feedback(created_at);
    CREATE INDEX IF NOT EXISTS idx_feedback_user_id ON feedback(user_id);
    
    -- Create feedback analytics view
    CREATE OR REPLACE VIEW feedback_analytics AS
    SELECT 
        type,
        severity,
        COUNT(*) as total_count,
        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as weekly_count,
        COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as daily_count,
        AVG(EXTRACT(EPOCH FROM (NOW() - created_at))/3600) as avg_age_hours
    FROM feedback
    GROUP BY type, severity;

---
# Feedback Analysis Dashboard
apiVersion: batch/v1
kind: CronJob
metadata:
  name: feedback-analysis
  namespace: monitoring
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: feedback-analyzer
            image: python:3.11-slim
            command:
            - /bin/sh
            - -c
            - |
              pip install requests pandas sqlalchemy psycopg2-binary numpy scikit-learn &&
              python /scripts/feedback_analyzer.py
            volumeMounts:
            - name: analyzer-scripts
              mountPath: /scripts
            env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: feedback-db-secret
                  key: database-url
            - name: SLACK_WEBHOOK_URL
              valueFrom:
                secretKeyRef:
                  name: notification-secrets
                  key: slack-webhook
          volumes:
          - name: analyzer-scripts
            configMap:
              name: feedback-analyzer-scripts
          restartPolicy: OnFailure

---
# PVC for feedback database
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: feedback-postgres-pvc
  namespace: monitoring
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi